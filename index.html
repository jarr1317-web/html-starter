<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Para Ti 💜</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #000;
      overflow: hidden;
      font-family: 'Courier New', monospace;
      color: #fff;
      touch-action: none;
      user-select: none;
    }

    /* Cargar fuente Fredoka One (similar a SeatYio) */
    @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    #cover {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, #1e003d 20%, #000 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 20;
      cursor: pointer;
      text-align: center;
      padding: 20px;
    }

    #cover h1 {
      font-size: 2.5rem;
      color: #ff69b4;
      text-shadow: 0 0 10px #ff69b4;
      margin-bottom: 10px;
    }

    #cover p {
      font-size: 1.2rem;
      color: #ba55d3;
      margin-bottom: 30px;
    }

    #cover .emoji {
      font-size: 3rem;
      animation: pulse 1s infinite alternate;
    }

    @keyframes pulse {
      from { transform: scale(1); }
      to { transform: scale(1.1); }
    }

    #instructions {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      padding: 6px 14px;
      border-radius: 15px;
      font-size: 14px;
      z-index: 5;
      text-align: center;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.2);
      animation: fadeIn 1.5s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    #music-controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.65);
      padding: 10px 20px;
      border-radius: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
      z-index: 10;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.25);
      font-size: 14px;
      flex-wrap: wrap;
      text-align: center;
    }

    #music-controls button {
      background: linear-gradient(45deg, #ff69b4, #ba55d3);
      color: white;
      border: none;
      padding: 6px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 15px;
      transition: transform 0.3s, background 0.3s;
    }

    #music-controls button:active {
      transform: scale(0.95);
      background: linear-gradient(45deg, #ff85c0, #9932cc);
    }
  </style>
</head>
<body>

  <div id="cover" role="button" tabindex="0" aria-label="Comenzar experiencia">
    <h1>Para ti, mi cielo 🌌</h1>
    <div class="emoji">💖</div>
    <p>👉 Toca para comenzar</p>
  </div>

  <div id="instructions">💖 Doble toque para corazones 💖 | Pincha con dos dedos o usa ⬆️⬇️</div>
  <canvas id="canvas"></canvas>

  <div id="music-controls">
    <button id="play-btn" aria-label="Reproducir o pausar música">⏸️ Pausar</button>
  </div>

  <audio id="bg-music" preload="auto" loop>
    <source src="https://github.com/user-attachments/files/22938986/ahi_estabas_tu.mp3" type="audio/mpeg">
    Tu navegador no soporta audio.
  </audio>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const bgMusic = document.getElementById("bg-music");
    const playBtn = document.getElementById("play-btn");
    const cover = document.getElementById("cover");

    let isPlaying = false;
    let isInitialized = false;
    let ringRotation = 0;

    let cameraDistance = 1;
    const minDistance = 0.8;
    const maxDistance = 3.0;

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    const baseMessages = [
      "Te quiero mucho 💖", "Anhelo tu sonrisa 😊", "Amo tu voz 🎶",
      "Tú eres mi todo 🌟", "Hola preciosa 👋", "Mi vida ❤️",
      "¿Por qué tan linda? 😍", "Te extraño 😢", "Te pienso 🤔",
      "Amo tus ojitos 👀", "Quiero que seas tú 💕", "Contigo 🌈",
      "Juntos siempre 💞", "Mi amor 💘", "Guapa 😘",
      "Mi cielo 🌌", "Eres mi todo 🌠", "Siempre tú 🌙",
      "Gracias por existir 🙏", "Me encantas 🥰", "Te aprecio 💫"
    ];

    const messageColors = [
      "#FF69B4", "#BA55D3", "#9370DB", "#DA70D6", "#EE82EE",
      "#FFB6C1", "#FFC0CB", "#E6E6FA", "#F0E68C", "#FFD700",
      "#48D1CC", "#00CED1", "#8A2BE2", "#9932CC", "#FF1493"
    ];

    // Distribuir mensajes en múltiples anillos
    const numRings = 5;
    const messagesPerRing = 20;
    const messages = [];

    for (let ring = 0; ring < numRings; ring++) {
      for (let i = 0; i < messagesPerRing; i++) {
        messages.push({
          text: baseMessages[Math.floor(Math.random() * baseMessages.length)],
          ringIndex: ring,
          angle: (i / messagesPerRing) * Math.PI * 2,
          color: messageColors[Math.floor(Math.random() * messageColors.length)]
        });
      }
    }

    const stars = Array.from({ length: 300 }, () => ({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      size: Math.random() * 1.2,
      alpha: Math.random(),
      speed: Math.random() * 0.05 + 0.01
    }));

    const moons = [
      { radius: 100, angle: 0, speed: 0.001, size: 3 },
      { radius: 140, angle: Math.PI/3, speed: 0.0008, size: 4 },
      { radius: 180, angle: Math.PI/2, speed: 0.0006, size: 5 },
      { radius: 220, angle: Math.PI, speed: 0.0005, size: 3.5 }
    ];

    // Zoom
    window.addEventListener("keydown", (e) => {
      if (!isInitialized) return;
      if (e.key === "ArrowUp") cameraDistance = Math.min(maxDistance, cameraDistance + 0.05);
      else if (e.key === "ArrowDown") cameraDistance = Math.max(minDistance, cameraDistance - 0.05);
    });

    let lastDistance = 0;
    document.addEventListener("touchstart", (e) => {
      if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastDistance = Math.sqrt(dx * dx + dy * dy);
      }
    });

    document.addEventListener("touchmove", (e) => {
      if (!isInitialized || e.touches.length !== 2) return;
      e.preventDefault();
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (lastDistance > 0) {
        const delta = distance - lastDistance;
        cameraDistance += delta * 0.002;
        cameraDistance = Math.max(minDistance, Math.min(maxDistance, cameraDistance));
      }
      lastDistance = distance;
    });

    cover.addEventListener("click", () => {
      if (!isInitialized) {
        isInitialized = true;
        cover.style.opacity = "0";
        cover.style.pointerEvents = "none";
        setTimeout(() => { if (cover.parentNode) cover.remove(); }, 600);
        bgMusic.play().catch(() => alert("Toca la pantalla para activar el sonido 🎵"));
        isPlaying = true;
        animate();
      }
    });

    function drawScene() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 🌌 FONDO CÓSMICO (nebulosa púrpura)
      const gradientBg = ctx.createRadialGradient(
        canvas.width / 2, canvas.height / 2, 0,
        canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height)
      );
      gradientBg.addColorStop(0, "#000");
      gradientBg.addColorStop(0.3, "#1e003d");
      gradientBg.addColorStop(0.6, "#3a005d");
      gradientBg.addColorStop(0.8, "#5d007f");
      gradientBg.addColorStop(1, "#1e003d");
      ctx.fillStyle = gradientBg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // ✨ Estrellas parpadeantes
      stars.forEach(s => {
        s.alpha += s.speed;
        if (s.alpha > 1) s.alpha = 0;
        ctx.fillStyle = `rgba(255,255,255,${s.alpha})`;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        ctx.fill();
      });

      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      const planetRadius = 60 * cameraDistance;

      // 🌠 Calcular profundidad (Z) de cada mensaje y ordenar por ella
      const messagesWithDepth = messages.map((msg, index) => {
        const baseRadius = 100 + msg.ringIndex * 30;
        const verticalScale = 0.2 + msg.ringIndex * 0.05;
        const a = msg.angle + ringRotation * (1 + msg.ringIndex * 0.2);

        const x = cx + Math.cos(a) * baseRadius * cameraDistance;
        const y = cy + Math.sin(a) * baseRadius * verticalScale * cameraDistance;

        // Profundidad: cuanto más cerca de π, más lejos (detrás del planeta)
        const depth = Math.cos(a); // -1 = detrás, 1 = adelante

        return { ...msg, x, y, angle: a, depth, index };
      });

      // Ordenar por profundidad: primero los más lejos (detrás), luego los más cerca (adelante)
      messagesWithDepth.sort((a, b) => a.depth - b.depth);

      // 1. Dibujar mensajes MÁS LEJOS (detrás del planeta) → APILADOS (más recientes arriba)
      // Filtrar y ordenar por índice inverso para apilar
      const behind = messagesWithDepth.filter(msg => msg.depth < 0.2);
      behind.sort((a, b) => b.index - a.index); // los más recientes arriba

      behind.forEach(msg => {
        ctx.font = `${14 + (cameraDistance - 0.8) * 5}px 'Fredoka One', cursive`;
        ctx.fillStyle = msg.color;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(msg.text, msg.x, msg.y);
      });

      // 2. Dibujar planeta (Saturno estilo foto)
      drawSaturn(cx, cy, planetRadius);

      // 3. Dibujar mensajes MÁS CERCA (adelante del planeta) → SEPARADOS (orden normal)
      const front = messagesWithDepth.filter(msg => msg.depth >= 0.2);
      front.forEach(msg => {
        ctx.font = `${14 + (cameraDistance - 0.8) * 5}px 'Fredoka One', cursive`;
        ctx.fillStyle = msg.color;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(msg.text, msg.x, msg.y);
      });

      // 4. Dibujar anillos de Saturno (encima del planeta pero debajo de mensajes adelante)
      drawSaturnRings(cx, cy, planetRadius);

      // 5. Lunas
      moons.forEach(moon => {
        moon.angle += moon.speed;
        const x = cx + Math.cos(moon.angle) * (moon.radius * cameraDistance);
        const y = cy + Math.sin(moon.angle) * (moon.radius * 0.25 * cameraDistance);
        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(x, y, moon.size * cameraDistance, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawSaturn(cx, cy, radius) {
      // Capa base: gradiente suave púrpura/rosa
      const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
      grad.addColorStop(0, "#FFD700");       // dorado central
      grad.addColorStop(0.3, "#FF69B4");     // rosa
      grad.addColorStop(0.6, "#BA55D3");     // orquídea
      grad.addColorStop(0.8, "#8A2BE2");     // violeta
      grad.addColorStop(1, "#4B0082");       // azul oscuro
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();

      // Bandas horizontales sutiles (textura)
      ctx.save();
      ctx.translate(cx, cy);
      const bands = [
        { offset: -0.6, color: "rgba(255,255,255,0.1)" },
        { offset: -0.3, color: "rgba(255,215,0,0.15)" },
        { offset: 0, color: "rgba(255,182,193,0.2)" },
        { offset: 0.3, color: "rgba(186,85,211,0.15)" },
        { offset: 0.6, color: "rgba(138,43,226,0.1)" }
      ];
      bands.forEach(band => {
        ctx.fillStyle = band.color;
        ctx.beginPath();
        ctx.ellipse(0, band.offset * radius, radius * 0.9, radius * 0.08, 0, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.restore();

      // Brillo lateral (como luz reflejada)
      const shine = ctx.createRadialGradient(cx - radius * 0.3, cy - radius * 0.3, 0, cx - radius * 0.3, cy - radius * 0.3, radius * 0.6);
      shine.addColorStop(0, "rgba(255,255,255,0.6)");
      shine.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = shine;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawSaturnRings(cx, cy, planetRadius) {
      ctx.save();
      ctx.translate(cx, cy);

      // Anillo exterior
      const outer = planetRadius * 2.5;
      const inner = planetRadius * 1.5;
      const gradient = ctx.createLinearGradient(-outer, 0, outer, 0);
      gradient.addColorStop(0, "rgba(255,215,0,0.1)");
      gradient.addColorStop(0.3, "rgba(186,85,211,0.4)");
      gradient.addColorStop(0.7, "rgba(255,105,180,0.4)");
      gradient.addColorStop(1, "rgba(255,215,0,0.1)");

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.ellipse(0, 0, outer, outer * 0.1, 0, 0, Math.PI * 2);
      ctx.ellipse(0, 0, inner, inner * 0.1, 0, 0, Math.PI * 2);
      ctx.fill("evenodd");

      // Anillo interior más fino
      const inner2 = planetRadius * 1.3;
      const outer2 = planetRadius * 1.8;
      const gradient2 = ctx.createLinearGradient(-outer2, 0, outer2, 0);
      gradient2.addColorStop(0, "rgba(255,255,255,0.1)");
      gradient2.addColorStop(0.5, "rgba(255,105,180,0.3)");
      gradient2.addColorStop(1, "rgba(255,255,255,0.1)");

      ctx.fillStyle = gradient2;
      ctx.beginPath();
      ctx.ellipse(0, 0, outer2, outer2 * 0.05, 0, 0, Math.PI * 2);
      ctx.ellipse(0, 0, inner2, inner2 * 0.05, 0, 0, Math.PI * 2);
      ctx.fill("evenodd");

      ctx.restore();
    }

    function animate() {
      if (!isInitialized) return;
      requestAnimationFrame(animate);
      ringRotation += 0.0008;
      drawScene();
    }

    // Audio
    playBtn.addEventListener("click", () => {
      if (!isPlaying) {
        bgMusic.play().catch(() => alert("Toca la pantalla para activar el sonido 🎵"));
      } else {
        bgMusic.pause();
      }
    });

    bgMusic.addEventListener("play", () => {
      if (isInitialized) {
        playBtn.textContent = "⏸️ Pausar";
        isPlaying = true;
      }
    });

    bgMusic.addEventListener("pause", () => {
      if (isInitialized) {
        playBtn.textContent = "▶️ Reproducir";
        isPlaying = false;
      }
    });

    // Corazones
    let lastTouchTime = 0;
    document.addEventListener("touchend", e => {
      const now = Date.now();
      if (now - lastTouchTime < 300) {
        const touch = e.changedTouches[0];
        if (touch) createHeart(touch);
      }
      lastTouchTime = now;
    });

    function createHeart(touch) {
      const heart = document.createElement("div");
      heart.textContent = "💖";
      heart.style.position = "fixed";
      heart.style.left = `${touch.clientX}px`;
      heart.style.top = `${touch.clientY}px`;
      heart.style.fontSize = "24px";
      heart.style.opacity = "1";
      heart.style.pointerEvents = "none";
      heart.style.zIndex = "100";
      heart.style.transition = "transform 1.2s ease, opacity 1.2s ease";
      heart.style.color = messageColors[Math.floor(Math.random() * messageColors.length)];
      document.body.appendChild(heart);
      setTimeout(() => {
        heart.style.transform = "translateY(-100px) scale(1.5)";
        heart.style.opacity = "0";
      }, 50);
      setTimeout(() => {
        if (heart.parentNode) heart.remove();
      }, 1300);
    }
  </script>
</body>
</html>